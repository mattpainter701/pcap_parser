{% extends "base.html" %}

{# Set full width flag for this template #}
{% set full_width = True %}

{% block title %}Network Visualization - {{ filename }}{% endblock %}

{% block head %}
<!-- Use local vis.js instead of CDN -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
<style>
    @import url("https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700");
    
    #network-container {
        width: 100vw;
        /* Calculate height to leave room for other elements */
        height: calc(100vh - 400px); /* Reduced height to fit everything on screen */
        border: 1px solid #ddd;
        background-color: #f8fafc;
        border-radius: 0;
        margin-left: calc(-50vw + 50%);
        margin-right: calc(-50vw + 50%);
        position: relative;
        overflow: hidden; /* Prevent scrollbars within container */
    }
    
    .control-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 12px;
        z-index: 10;
        width: 250px;
    }
    
    .node-tooltip {
        background-color: white;
        padding: 8px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        font-size: 12px;
    }
    
    .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
    }
    
    .legend-color {
        width: 12px;
        height: 12px;
        margin-right: 5px;
        border-radius: 2px;
    }
    
    /* Make controls container full width but with padding */
    .controls-container {
        padding: 0 1rem;
        width: 100%;
        max-width: 100%;
    }
    
    /* More compact spacing */
    .compact-controls {
        margin-bottom: 0.75rem;
        padding: 0.75rem;
    }
    
    .compact-legend {
        margin-top: 0.75rem;
        padding: 0.5rem 1rem;
    }
</style>
{% endblock %}

{% block content %}
<!-- Make header more compact -->
<div class="controls-container mb-2 flex justify-between items-center">
    <div>
        <h2 class="text-xl font-bold text-gray-800">
            <i class="fas fa-project-diagram mr-2 text-primary"></i> 
            Network Visualization: {{ filename }}
        </h2>
    </div>
    <a href="{{ url_for('index') }}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-1 px-3 rounded-md inline-flex items-center transition-colors text-sm">
        <i class="fas fa-arrow-left mr-2"></i> Back
    </a>
</div>

<!-- Make controls more compact -->
<div class="controls-container bg-white rounded-lg shadow-md p-3 mb-3 compact-controls">
    <div class="flex flex-wrap gap-2 mb-2">
        <!-- Search box -->
        <div class="flex-grow max-w-md">
            <div class="relative">
                <input type="text" id="search-input" class="w-full pl-10 pr-4 py-2 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Search nodes...">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <i class="fas fa-search text-gray-400"></i>
                </div>
            </div>
        </div>
        
        <!-- Filter buttons -->
        <div class="flex space-x-2">
            <button id="filter-all" class="bg-primary text-white py-2 px-4 rounded-md hover:bg-opacity-90 transition-colors">
                <i class="fas fa-globe-americas mr-1"></i> All
            </button>
            <button id="filter-mac" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-network-wired mr-1"></i> MAC
            </button>
            <button id="filter-ip" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-sitemap mr-1"></i> IP
            </button>
        </div>
    </div>
    
    <div class="flex flex-wrap gap-2">
        <!-- Layout controls -->
        <div class="flex space-x-2">
            <button id="layout-hierarchical" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-sitemap mr-1"></i> Hierarchical
            </button>
            <button id="layout-physics" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-atom mr-1"></i> Disjoint Force-Directed
            </button>
        </div>
        
        <!-- Action buttons -->
        <div class="flex space-x-2 ml-auto">
            <button id="btn-fullscreen" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-expand mr-1"></i> Fullscreen
            </button>
            <button id="btn-export" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-download mr-1"></i> Export
            </button>
        </div>
    </div>
</div>

<!-- Fix the visualization container structure to match JavaScript expectations -->
<div id="network-container">
    <!-- Add search box -->
    <div class="search-box">
        <input type="text" id="search-input" placeholder="Search by IP or MAC">
        <button id="search-button">Search</button>
    </div>
    <div id="network"></div>
</div>

<!-- Simplified and more compact legend -->
<div class="controls-container flex items-center bg-white rounded-lg shadow-md compact-legend">
    <span class="text-sm font-medium text-gray-700 mr-3">Legend:</span>
    <div class="legend">
        <div class="legend-item mr-4">
            <div class="legend-color" style="background-color: #4f46e5;"></div>
            <span class="text-xs">MAC Address</span>
        </div>
        <div class="legend-item mr-4">
            <div class="legend-color" style="background-color: #10b981;"></div>
            <span class="text-xs">IP Address</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #000; height: 2px;"></div>
            <span class="text-xs">Connection</span>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Use local vis.js instead of CDN -->
<script src="{{ url_for('static', filename='js/vis-network-bundle.js') }}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
    // Make network, allNodes, and allEdges available in the global scope for all functions
    let network = null;
    let allNodes = null;
    let allEdges = null;
    
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize datasets - use empty arrays initially
        allNodes = new vis.DataSet([]);
        allEdges = new vis.DataSet([]);
        
        // Fix: Get the correct container element
        const container = document.getElementById('network');
        
        // Define different node groups with distinctive styles
        const groups = {
            mac: {
                color: {
                    background: '#ddd',  // Light gray fill like in the demo
                    border: '#666',      // Dark gray border like in the demo
                    highlight: {
                        background: '#ccc',
                        border: '#444'
                    }
                },
                font: {
                    color: '#000000',
                    size: 10,            // Smaller font like in the demo
                    face: 'Roboto Condensed'  // Font family used in the demo
                },
                borderWidth: 1,          // Thinner border like in the demo
                shape: 'circle',         // Circle shape like in the demo
                size: 25                 // Same size as in the demo (nodeRadius = 25)
            },
            ip: {
                color: {
                    background: '#ddd',  // Light gray fill like in the demo
                    border: '#666',      // Dark gray border like in the demo
                    highlight: {
                        background: '#ccc',
                        border: '#444'
                    }
                },
                font: {
                    color: '#000000',
                    size: 10,            // Smaller font like in the demo
                    face: 'Roboto Condensed'  // Font family used in the demo
                },
                borderWidth: 1,          // Thinner border like in the demo
                shape: 'circle',         // Circle shape like in the demo
                size: 25,                // Same size as in the demo (nodeRadius = 25)
                margin: 10               // Less margin to match the demo
            }
        };
        
        // Edge styling
        const edgesOptions = {
            color: {
                color: '#666',           // Gray color like in the demo
                highlight: '#444',
                hover: '#444'
            },
            width: 1.5,                  // Thinner edges like in the demo (stroke-width: 1.5px)
            font: {
                align: 'middle',
                size: 10,
                face: 'Roboto Condensed', // Font family used in the demo
                strokeWidth: 4,           // Text shadow effect like in the demo
                strokeColor: '#ffffff'    // White text shadow like in the demo
            },
            selectionWidth: 2,
            smooth: {
                type: 'straightCross',    // Straight lines like in the demo's "L" path
                roundness: 0
            }
        };
        
        // Network visualization options
        const options = {
            nodes: {
                font: {
                    size: 12,
                    face: 'Roboto'
                },
                margin: 10,
                shape: 'box',
                scaling: {
                    min: 16,
                    max: 32
                }
            },
            edges: edgesOptions,
            groups: groups,
            physics: {
                enabled: true,
                // D3-style physics configuration as default
                barnesHut: {
                    gravitationalConstant: -2000,     // Similar to d3.forceManyBody().strength(-200)
                    centralGravity: 0.01,             // Weak central gravity like in D3
                    springLength: 200,                // Similar to d3.forceLink().distance(200)
                    springConstant: 0.04,             // Moderate spring constant
                    damping: 0.09,
                    avoidOverlap: 1.0                 // Maximum avoidance (d3.forceCollide)
                },
                solver: 'barnesHut',
                stabilization: {
                    enabled: true,
                    iterations: 250,                  // More iterations for better stability
                    updateInterval: 25,
                    onlyDynamicEdges: false,
                    fit: true
                },
                timestep: 0.3,                        // Smaller timestep for more stable simulation
                adaptiveTimestep: true,
                maxVelocity: 50,                      // Allow higher velocity initially (d3.alphaTarget(0.3))
                minVelocity: 0.15                     // Lower minimum velocity (d3's low friction)
            },
            interaction: {
                hover: true,
                tooltipDelay: 200,
                navigationButtons: true,
                keyboard: true,
                zoomView: true
            },
            layout: {
                randomSeed: 1,
                improvedLayout: true,
                clusterThreshold: 150             // Better clustering behavior
            }
        };
        
        // Create an initial empty network with empty datasets
        const networkData = {
            nodes: allNodes,
            edges: allEdges
        };
        
        // Initialize the network with empty data to ensure it exists
        if (container) {
            network = new vis.Network(container, networkData, options);
            console.log("Network initialized with empty data");
        } else {
            console.error("Network container not found!");
            return;
        }
        
        // Load the network data from the API
        fetch(`/api/network_data/{{ filename }}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Received network data:", data);
                
                try {
                    if (!data || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
                        console.error("Invalid data format:", data);
                        throw new Error("Invalid data format received from server");
                    }
                    
                    // Clear existing data
                    allNodes.clear();
                    allEdges.clear();
                    
                    // Add the new data
                    allNodes.add(data.nodes);
                    allEdges.add(data.edges);
                    
                    console.log(`Loaded ${allNodes.length} nodes and ${allEdges.length} edges`);
                    
                    // Update the network with new data
                    network.setData({
                        nodes: allNodes,
                        edges: allEdges
                    });
                    
                    console.log("Network is ready, applying default layout");
                    
                } catch (err) {
                    console.error("Error setting up network data:", err);
                }
                
                // Register network events only after data is loaded
                setupNetworkEvents();
                
            })
            .catch(error => {
                console.error("Error fetching network data:", error);
            });
            
        // Setup all network event handlers
        function setupNetworkEvents() {
            if (!network) {
                console.error("Cannot setup events: network not initialized");
                return;
            }
            
            // Double-click event
            network.on("doubleClick", function(params) {
                if (params.nodes && params.nodes.length > 0) {
                    // Focus on the selected node
                    network.focus(params.nodes[0], {
                        scale: 1.2,
                        animation: true
                    });
                }
            });
            
            // Stabilization complete event
            network.once("stabilizationIterationsDone", function() {
                console.log("Network stabilized");
                
                // Safely check if methods exist before calling them
                if (network && typeof network.getNodeIds === 'function') {
                    // Apply a final layout adjustment to spread nodes further
                    applyFinalLayoutAdjustment();
                } else {
                    console.warn("Network is not properly initialized or doesn't have getNodeIds method");
                }
                
                // Make sure to call resize after stabilization
                setTimeout(resizeNetwork, 100);
            });
            
            // Add search functionality
            const searchButton = document.getElementById('search-button');
            const searchInput = document.getElementById('search-input');
            
            if (searchButton) {
                searchButton.addEventListener('click', performSearch);
            }
            
            if (searchInput) {
                searchInput.addEventListener('keyup', function(event) {
                    if (event.key === "Enter") {
                        performSearch();
                    }
                });
            }
        }
        
        // Apply final layout adjustments to improve node placement
        function applyFinalLayoutAdjustment() {
            if (!network || typeof network.getNodeIds !== 'function') {
                console.warn("Cannot apply layout adjustment: network methods not available");
                return;
            }
            
            try {
                const nodeIds = network.getNodeIds();
                if (!nodeIds || !nodeIds.length) {
                    console.warn("No nodes found for layout adjustment");
                    return;
                }
                
                const positions = network.getPositions(nodeIds);
                
                // Group nodes by type
                const ipNodes = allNodes.get().filter(node => node.group === 'ip').map(node => node.id);
                const macNodes = allNodes.get().filter(node => node.group === 'mac').map(node => node.id);
                
                // Scale positions outward by different factors based on node type
                for (const nodeId of nodeIds) {
                    const pos = positions[nodeId];
                    if (!pos) continue;
                    
                    if (ipNodes.includes(nodeId)) {
                        // IP nodes get expanded more (40% scaling)
                        network.moveNode(nodeId, pos.x * 1.4, pos.y * 1.4);
                    } else {
                        // MAC nodes get normal expansion (20% scaling)
                        network.moveNode(nodeId, pos.x * 1.2, pos.y * 1.2);
                    }
                }
                
                // Disable physics after stabilization
                network.setOptions({ physics: { enabled: false } });
                
                console.log("Applied final layout adjustment");
            } catch (err) {
                console.error("Error applying layout adjustment:", err);
            }
        }
        
        // Perform search on node data
        function performSearch() {
            if (!network || typeof network.getNodeIds !== 'function' || !allNodes) {
                console.warn("Search functionality unavailable: network not properly initialized");
                return;
            }
            
            const searchInput = document.getElementById('search-input');
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.trim().toLowerCase();
            if (!searchTerm) return;
            
            console.log("Searching for:", searchTerm);
            
            try {
                // Get all nodes
                const nodeIds = network.getNodeIds();
                const foundNodes = [];
                
                // Search through nodes
                nodeIds.forEach(id => {
                    const node = allNodes.get(id);
                    if (node && node.label && node.label.toLowerCase().includes(searchTerm)) {
                        foundNodes.push(id);
                    }
                });
                
                if (foundNodes.length > 0) {
                    // Focus on the first match
                    network.focus(foundNodes[0], {
                        scale: 1.2,
                        animation: true
                    });
                    network.selectNodes(foundNodes);
                    
                    // Highlight the found nodes
                    const updatedNodes = foundNodes.map(id => {
                        const node = allNodes.get(id);
                        if (!node) return null;
                        
                        const originalColor = node.color ? { ...node.color } : null;
                        
                        return {
                            id: id,
                            color: {
                                background: '#FFFF00',
                                border: '#FFA500',
                                highlight: {
                                    background: '#FFFF00',
                                    border: '#FFA500'
                                },
                                _originalColor: originalColor
                            }
                        };
                    }).filter(node => node !== null);
                    
                    allNodes.update(updatedNodes);
                    
                    // Reset highlight after a delay
                    setTimeout(() => {
                        const resetNodes = foundNodes.map(id => {
                            const node = allNodes.get(id);
                            if (!node) return null;
                            
                            return {
                                id: id,
                                color: node.color._originalColor
                            };
                        }).filter(node => node !== null);
                        
                        allNodes.update(resetNodes);
                    }, 3000);
                    
                    console.log(`Found ${foundNodes.length} nodes matching "${searchTerm}"`);
                } else {
                    console.log(`No nodes found matching "${searchTerm}"`);
                    alert(`No nodes found matching "${searchTerm}"`);
                }
            } catch (err) {
                console.error("Error during search:", err);
            }
        }
        
        // Handle layout changes
        const layoutHierarchicalBtn = document.getElementById('layout-hierarchical');
        const layoutPhysicsBtn = document.getElementById('layout-physics');
        
        if (layoutHierarchicalBtn) {
            layoutHierarchicalBtn.addEventListener('click', function() {
                if (!network) return;
                applyHierarchicalLayout();
            });
        }
        
        if (layoutPhysicsBtn) {
            layoutPhysicsBtn.addEventListener('click', function() {
                if (!network) return;
                applyForceDirectedLayout();
            });
        }
        
        // Handle window resize
        function resizeNetwork() {
            if (!network || typeof network.setSize !== 'function') {
                console.warn("Network is not properly initialized or doesn't have setSize method");
                return;
            }
            
            const container = document.getElementById('network-container');
            if (!container) return;
            
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            
            if (width > 0 && height > 0) {
                try {
                    network.setSize(`${width}px`, `${height}px`);
                    network.fit();
                } catch (err) {
                    console.error("Error resizing network:", err);
                }
            }
        }
        
        // Apply hierarchical layout
        function applyHierarchicalLayout() {
            if (!network) return;
            
            console.log("Switching to Hierarchical view");
            
            try {
                // Set up hierarchical layout
                network.setOptions({
                    layout: {
                        hierarchical: {
                            direction: 'UD',
                            sortMethod: 'directed',
                            nodeSpacing: 150,
                            treeSpacing: 200
                        }
                    },
                    physics: {
                        enabled: true,
                        hierarchicalRepulsion: {
                            centralGravity: 0.2,
                            springLength: 150,
                            springConstant: 0.01,
                            nodeDistance: 120,
                            damping: 0.09
                        },
                        solver: 'hierarchicalRepulsion',
                        stabilization: {
                            enabled: true,
                            iterations: 1000,
                            updateInterval: 100
                        }
                    }
                });
                
                // Highlight the active button
                document.getElementById('layout-hierarchical').classList.remove('bg-gray-200');
                document.getElementById('layout-hierarchical').classList.add('bg-primary', 'text-white');
                document.getElementById('layout-physics').classList.remove('bg-primary', 'text-white');
                document.getElementById('layout-physics').classList.add('bg-gray-200', 'text-gray-800');
            } catch (err) {
                console.error("Error applying hierarchical layout:", err);
            }
        }
        
        // Apply force-directed layout
        function applyForceDirectedLayout() {
            if (!network) return;
            
            console.log("Switching to Disjoint Force-Directed view");
            
            try {
                // Disable hierarchical layout and apply force-directed
                network.setOptions({
                    layout: {
                        hierarchical: false,
                        improvedLayout: true
                    },
                    physics: {
                        enabled: true,
                        barnesHut: {
                            gravitationalConstant: -2000,
                            centralGravity: 0.3,
                            springLength: 150,
                            springConstant: 0.04,
                            damping: 0.09,
                            avoidOverlap: 1.0
                        },
                        solver: 'barnesHut',
                        stabilization: {
                            enabled: true,
                            iterations: 1000,
                            updateInterval: 100
                        }
                    }
                });
                
                // Highlight the active button
                document.getElementById('layout-physics').classList.remove('bg-gray-200');
                document.getElementById('layout-physics').classList.add('bg-primary', 'text-white');
                document.getElementById('layout-hierarchical').classList.remove('bg-primary', 'text-white');
                document.getElementById('layout-hierarchical').classList.add('bg-gray-200', 'text-gray-800');
                
                // Apply force-directed layout
                console.log("Rendering force-directed layout");
                network.startSimulation();
            } catch (err) {
                console.error("Error applying force-directed layout:", err);
            }
        }
        
        // Handle fullscreen button
        const fullscreenBtn = document.getElementById('btn-fullscreen');
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', function() {
                const container = document.getElementById('network-container');
                if (!container) return;
                
                if (!document.fullscreenElement) {
                    if (container.requestFullscreen) {
                        container.requestFullscreen();
                    } else if (container.mozRequestFullScreen) {
                        container.mozRequestFullScreen();
                    } else if (container.webkitRequestFullscreen) {
                        container.webkitRequestFullscreen();
                    } else if (container.msRequestFullscreen) {
                        container.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            });
        }
        
        // Handle window resize event
        window.addEventListener('resize', function() {
            resizeNetwork();
        });
        
        // Listen for fullscreen change to resize network
        document.addEventListener('fullscreenchange', resizeNetwork);
        document.addEventListener('webkitfullscreenchange', resizeNetwork);
        document.addEventListener('mozfullscreenchange', resizeNetwork);
        document.addEventListener('MSFullscreenChange', resizeNetwork);
    });
</script>

<script>
  document.addEventListener("DOMContentLoaded", function() {
    const btnPhysics = document.getElementById('layout-physics');
    
    // Create a function to check if network is ready and then apply the layout
    function tryApplyDefaultLayout() {
        if (network && typeof network.setOptions === 'function') {
            console.log("Network is ready, applying default layout");
            if (btnPhysics) {
                // Make sure to handle any errors during default layout application
                try {
                    btnPhysics.click();
                } catch (error) {
                    console.error("Error applying default layout:", error);
                }
            }
        } else {
            console.log("Waiting for network to initialize...");
            // Limit retry attempts to avoid infinite loop
            if (window.networkInitAttempts === undefined) {
                window.networkInitAttempts = 0;
            }
            window.networkInitAttempts++;
            
            if (window.networkInitAttempts < 20) { // Limit to 10 seconds (20 * 500ms)
                setTimeout(tryApplyDefaultLayout, 500);
            } else {
                console.error("Failed to initialize network after multiple attempts");
            }
        }
    }
    
    // Start checking after a delay to allow for initial page load
    setTimeout(tryApplyDefaultLayout, 1000);
  });
</script>
{% endblock %} 