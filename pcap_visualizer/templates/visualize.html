{% extends "base.html" %}

{# Set full width flag for this template #}
{% set full_width = True %}

{% block title %}Network Visualization - {{ filename }}{% endblock %}

{% block head %}
<!-- Use local vis.js instead of CDN -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
<style>
    @import url("https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700");
    
    #network-container {
        width: 100vw;
        /* Calculate height to leave room for other elements */
        height: calc(100vh - 400px); /* Reduced height to fit everything on screen */
        border: 1px solid #ddd;
        background-color: #f8fafc;
        border-radius: 0;
        margin-left: calc(-50vw + 50%);
        margin-right: calc(-50vw + 50%);
        position: relative;
        overflow: hidden; /* Prevent scrollbars within container */
    }
    
    .control-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 12px;
        z-index: 10;
        width: 250px;
    }
    
    .node-tooltip {
        background-color: white;
        padding: 8px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        font-size: 12px;
    }
    
    .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
    }
    
    .legend-color {
        width: 12px;
        height: 12px;
        margin-right: 5px;
        border-radius: 2px;
    }
    
    /* Make controls container full width but with padding */
    .controls-container {
        padding: 0 1rem;
        width: 100%;
        max-width: 100%;
    }
    
    /* More compact spacing */
    .compact-controls {
        margin-bottom: 0.75rem;
        padding: 0.75rem;
    }
    
    .compact-legend {
        margin-top: 0.75rem;
        padding: 0.5rem 1rem;
    }
</style>
{% endblock %}

{% block content %}
<!-- Make header more compact -->
<div class="controls-container mb-2 flex justify-between items-center">
    <div>
        <h2 class="text-xl font-bold text-gray-800">
            <i class="fas fa-project-diagram mr-2 text-primary"></i> 
            Network Visualization: {{ filename }}
        </h2>
    </div>
    <a href="{{ url_for('index') }}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-1 px-3 rounded-md inline-flex items-center transition-colors text-sm">
        <i class="fas fa-arrow-left mr-2"></i> Back
    </a>
</div>

<!-- Make controls more compact -->
<div class="controls-container bg-white rounded-lg shadow-md p-3 mb-3 compact-controls">
    <div class="flex flex-wrap gap-2 mb-2">
        <!-- Search box -->
        <div class="flex-grow max-w-md">
            <div class="relative">
                <input type="text" id="search-input" class="w-full pl-10 pr-4 py-2 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Search nodes...">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <i class="fas fa-search text-gray-400"></i>
                </div>
            </div>
        </div>
        
        <!-- Filter buttons -->
        <div class="flex space-x-2">
            <button id="filter-all" class="bg-primary text-white py-2 px-4 rounded-md hover:bg-opacity-90 transition-colors">
                <i class="fas fa-globe-americas mr-1"></i> All
            </button>
            <button id="filter-mac" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-network-wired mr-1"></i> MAC
            </button>
            <button id="filter-ip" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-sitemap mr-1"></i> IP
            </button>
        </div>
    </div>
    
    <div class="flex flex-wrap gap-2">
        <!-- Layout controls -->
        <div class="flex space-x-2">
            <button id="layout-hierarchical" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-sitemap mr-1"></i> Hierarchical
            </button>
            <button id="layout-physics" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-atom mr-1"></i> Disjoint Force-Directed
            </button>
        </div>
        
        <!-- Action buttons -->
        <div class="flex space-x-2 ml-auto">
            <button id="btn-fullscreen" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-expand mr-1"></i> Fullscreen
            </button>
            <button id="btn-export" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-download mr-1"></i> Export
            </button>
        </div>
    </div>
</div>

<!-- Fix the visualization container structure to match JavaScript expectations -->
<div id="network-container">
    <!-- Add search box -->
    <div class="search-box">
        <input type="text" id="search-input" placeholder="Search by IP or MAC">
        <button id="search-button">Search</button>
    </div>
    <div id="network"></div>
</div>

<!-- Simplified and more compact legend -->
<div class="controls-container flex items-center bg-white rounded-lg shadow-md compact-legend">
    <span class="text-sm font-medium text-gray-700 mr-3">Legend:</span>
    <div class="legend">
        <div class="legend-item mr-4">
            <div class="legend-color" style="background-color: #4f46e5;"></div>
            <span class="text-xs">MAC Address</span>
        </div>
        <div class="legend-item mr-4">
            <div class="legend-color" style="background-color: #10b981;"></div>
            <span class="text-xs">IP Address</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #000; height: 2px;"></div>
            <span class="text-xs">Connection</span>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Use local vis.js instead of CDN -->
<script src="{{ url_for('static', filename='js/vis-network-bundle.js') }}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
    // Make network, allNodes, and allEdges available in the global scope for all functions
    let network = null;
    let allNodes = null;
    let allEdges = null;
    
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize datasets
        allNodes = new vis.DataSet([]);
        allEdges = new vis.DataSet([]);
        
        // Fix: Get the correct container element
        const container = document.getElementById('network');
        
        // Define different node groups with distinctive styles
        const groups = {
            mac: {
                color: {
                    background: '#ddd',  // Light gray fill like in the demo
                    border: '#666',      // Dark gray border like in the demo
                    highlight: {
                        background: '#ccc',
                        border: '#444'
                    }
                },
                font: {
                    color: '#000000',
                    size: 10,            // Smaller font like in the demo
                    face: 'Roboto Condensed'  // Font family used in the demo
                },
                borderWidth: 1,          // Thinner border like in the demo
                shape: 'circle',         // Circle shape like in the demo
                size: 25                 // Same size as in the demo (nodeRadius = 25)
            },
            ip: {
                color: {
                    background: '#ddd',  // Light gray fill like in the demo
                    border: '#666',      // Dark gray border like in the demo
                    highlight: {
                        background: '#ccc',
                        border: '#444'
                    }
                },
                font: {
                    color: '#000000',
                    size: 10,            // Smaller font like in the demo
                    face: 'Roboto Condensed'  // Font family used in the demo
                },
                borderWidth: 1,          // Thinner border like in the demo
                shape: 'circle',         // Circle shape like in the demo
                size: 25,                // Same size as in the demo (nodeRadius = 25)
                margin: 10               // Less margin to match the demo
            }
        };
        
        // Edge styling
        const edgesOptions = {
            color: {
                color: '#666',           // Gray color like in the demo
                highlight: '#444',
                hover: '#444'
            },
            width: 1.5,                  // Thinner edges like in the demo (stroke-width: 1.5px)
            font: {
                align: 'middle',
                size: 10,
                face: 'Roboto Condensed', // Font family used in the demo
                strokeWidth: 4,           // Text shadow effect like in the demo
                strokeColor: '#ffffff'    // White text shadow like in the demo
            },
            selectionWidth: 2,
            smooth: {
                type: 'straightCross',    // Straight lines like in the demo's "L" path
                roundness: 0
            }
        };
        
        // Network visualization options
        const options = {
            nodes: {
                font: {
                    size: 12,
                    face: 'Roboto'
                },
                margin: 10,
                shape: 'box',
                scaling: {
                    min: 16,
                    max: 32
                }
            },
            edges: edgesOptions,
            groups: groups,
            physics: {
                enabled: true,
                // D3-style physics configuration as default
                barnesHut: {
                    gravitationalConstant: -2000,     // Similar to d3.forceManyBody().strength(-200)
                    centralGravity: 0.01,             // Weak central gravity like in D3
                    springLength: 200,                // Similar to d3.forceLink().distance(200)
                    springConstant: 0.04,             // Moderate spring constant
                    damping: 0.09,
                    avoidOverlap: 1.0                 // Maximum avoidance (d3.forceCollide)
                },
                solver: 'barnesHut',
                stabilization: {
                    enabled: true,
                    iterations: 250,                  // More iterations for better stability
                    updateInterval: 25,
                    onlyDynamicEdges: false,
                    fit: true
                },
                timestep: 0.3,                        // Smaller timestep for more stable simulation
                adaptiveTimestep: true,
                maxVelocity: 50,                      // Allow higher velocity initially (d3.alphaTarget(0.3))
                minVelocity: 0.15                     // Lower minimum velocity (d3's low friction)
            },
            interaction: {
                hover: true,
                tooltipDelay: 200,
                navigationButtons: true,
                keyboard: true,
                zoomView: true
            },
            layout: {
                randomSeed: 1,
                improvedLayout: true,
                clusterThreshold: 150             // Better clustering behavior
            }
        };
        
        // Load the network data from the API
        fetch(`/api/network_data/{{ filename }}`)
            .then(response => response.json())
            .then(data => {
                console.log("Received network data:", data);
                
                try {
                    // Make deep copies to avoid reference issues
                    const nodeData = Array.isArray(data.nodes) ? [...data.nodes] : [];
                    const edgeData = Array.isArray(data.edges) ? [...data.edges] : [];

                    // Create new datasets with the copied data
                    allNodes = new vis.DataSet(nodeData);
                    allEdges = new vis.DataSet(edgeData);
                    
                    // Verify that the datasets have been created successfully
                    console.log(`Created network with ${allNodes.length} nodes and ${allEdges.length} edges`);
                    
                    // Create the network with the new datasets
                    const networkData = {
                        nodes: allNodes,
                        edges: allEdges
                    };
                    
                    console.log("Creating network with container:", container);
                    console.log("Container exists:", !!container);
                    if (container) {
                        console.log("Container dimensions:", container.offsetWidth, "x", container.offsetHeight);
                    }
                    
                    // Initialize the global network variable
                    network = new vis.Network(container, networkData, options);
                } catch (err) {
                    console.error("Error setting up network data:", err);
                    throw err;
                }
                
                // Ensure network is fully initialized before registering events
                if (network) {
                    // Network events
                    network.on("doubleClick", function(params) {
                        if (params.nodes.length > 0) {
                            // Focus on the selected node
                            network.focus(params.nodes[0], {
                                scale: 1.2,
                                animation: true
                            });
                        }
                    });
                    
                    // Stabilize the network for better initial layout
                    network.once("stabilizationIterationsDone", function() {
                        console.log("Network stabilized");
                        
                        if (!network || typeof network.getNodeIds !== 'function') {
                            console.warn("Network is not properly initialized or doesn't have getNodeIds method");
                            return;
                        }
                        
                        // Apply a final layout adjustment to spread nodes further
                        const nodeIds = network.getNodeIds();
                        const positions = network.getPositions(nodeIds);
                        const nodeData = allNodes.get();
                        
                        // Group nodes by type
                        const ipNodes = nodeData.filter(node => node.group === 'ip').map(node => node.id);
                        const macNodes = nodeData.filter(node => node.group === 'mac').map(node => node.id);
                        
                        // Scale positions outward by different factors based on node type
                        // IP nodes get more expansion than MAC nodes
                        for (const nodeId of nodeIds) {
                            const pos = positions[nodeId];
                            if (ipNodes.includes(nodeId)) {
                                // IP nodes get expanded more (40% scaling)
                                network.moveNode(nodeId, pos.x * 1.4, pos.y * 1.4);
                            } else {
                                // MAC nodes get normal expansion (20% scaling)
                                network.moveNode(nodeId, pos.x * 1.2, pos.y * 1.2);
                            }
                        }
                        
                        // Disable physics after stabilization
                        network.setOptions({ physics: { enabled: false } });
                        
                        // Call resize after stabilization
                        setTimeout(resizeNetwork, 100);
                    });
                } else {
                    console.error("Failed to initialize network");
                }
                
                // Add search functionality
                document.getElementById('search-button').addEventListener('click', performSearch);
                document.getElementById('search-input').addEventListener('keyup', function(event) {
                    if (event.key === "Enter") {
                        performSearch();
                    }
                });
                
                function performSearch() {
                    const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
                    if (!searchTerm) return;
                    
                    console.log("Searching for:", searchTerm);
                    
                    // Get all nodes
                    const nodeIds = network.getNodeIds();
                    const foundNodes = [];
                    
                    // Search through nodes
                    nodeIds.forEach(id => {
                        const node = networkData.nodes.get(id);
                        if (node.label.toLowerCase().includes(searchTerm)) {
                            foundNodes.push(id);
                        }
                    });
                    
                    if (foundNodes.length > 0) {
                        // Focus on the first match
                        network.focus(foundNodes[0], {
                            scale: 1.2,
                            animation: true
                        });
                        network.selectNodes(foundNodes);
                        
                        // Highlight the found nodes
                        const updatedNodes = foundNodes.map(id => {
                            const node = networkData.nodes.get(id);
                            const originalColor = node.color ? { ...node.color } : null;
                            
                            return {
                                id: id,
                                color: {
                                    background: '#FFFF00',
                                    border: '#FFA500',
                                    highlight: {
                                        background: '#FFFF00',
                                        border: '#FFA500'
                                    },
                                    _originalColor: originalColor
                                }
                            };
                        });
                        
                        networkData.nodes.update(updatedNodes);
                        
                        // Reset highlight after a delay
                        setTimeout(() => {
                            const resetNodes = foundNodes.map(id => {
                                const node = networkData.nodes.get(id);
                                return {
                                    id: id,
                                    color: node.color._originalColor
                                };
                            });
                            networkData.nodes.update(resetNodes);
                        }, 3000);
                        
                        console.log(`Found ${foundNodes.length} nodes matching "${searchTerm}"`);
                    } else {
                        console.log(`No nodes found matching "${searchTerm}"`);
                        alert(`No nodes found matching "${searchTerm}"`);
                    }
                }
                
                // Apply D3-style collision handling and boundary forces after initial stabilization
                network.once('stabilizationIterationsDone', function() {
                    console.log("Initial force-directed layout stabilized");
                    
                    setTimeout(() => {
                        // Apply collision handling and boundary forces
                        const nodeIds = network.getNodeIds();
                        const positions = network.getPositions(nodeIds);
                        const containerRect = document.getElementById('network-container').getBoundingClientRect();
                        
                        // Get dimensions for boundary constraints (similar to D3 example's transform function)
                        const width = containerRect.width;
                        const height = containerRect.height;
                        const nodeRadius = 25; // Similar to D3 example
                        const forcePadding = nodeRadius + 10;
                        
                        // Apply container boundary constraints to keep nodes within visible area
                        nodeIds.forEach(nodeId => {
                            const pos = positions[nodeId];
                            if (!pos) return;
                            
                            // Apply boundary constraints exactly like in the demo's transform function
                            let x = pos.x;
                            let y = pos.y;
                            
                            x = x <= forcePadding ? forcePadding : 
                                x >= width - forcePadding ? width - forcePadding : x;
                            y = y <= forcePadding ? forcePadding : 
                                y >= height - forcePadding ? height - forcePadding : y;
                            
                            // Move node if needed
                            if (x !== pos.x || y !== pos.y) {
                                network.moveNode(nodeId, x, y);
                            }
                        });
                        
                        // Set gentler physics for ongoing simulation
                        network.setOptions({
                            physics: {
                                enabled: true,
                                maxVelocity: 5,        // Reduce max velocity after layout
                                minVelocity: 0.1,      // Gentle movement threshold
                                stabilization: {
                                    enabled: false     // Disable further full stabilization
                                }
                            }
                        });
                    }, 1000);
                });
                
                // Set up search functionality
                setupSearch(network, allNodes);
                
                // Set up filter buttons
                setupFilters(network, allNodes, allEdges);
                
                // Set up layout buttons
                setupLayouts(network);
                
                // Set up action buttons
                setupActionButtons(network, container);

                // Add connection type styling like in the demo
                updateEdgesWithTypeStyles();
            })
            .catch(error => {
                console.error('Error loading network data:', error);
                container.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-full">
                        <i class="fas fa-exclamation-triangle text-error text-4xl mb-4"></i>
                        <h3 class="text-xl font-bold text-gray-800 mb-2">Error Loading Data</h3>
                        <p class="text-gray-600">Failed to load network data: ${error.message}</p>
                    </div>
                `;
            });
        
        // Setup search functionality
        function setupSearch(network, nodes) {
            const searchInput = document.getElementById('search-input');
            searchInput.addEventListener('input', function(e) {
                const searchTerm = e.target.value.toLowerCase();
                
                if (searchTerm === '') {
                    // Reset all nodes to visible
                    nodes.forEach(node => {
                        nodes.update({ id: node.id, hidden: false });
                    });
                    return;
                }
                
                // Hide nodes that don't match the search term
                nodes.forEach(node => {
                    const label = (node.label || '').toLowerCase();
                    const title = (node.title || '').toLowerCase();
                    const matches = label.includes(searchTerm) || title.includes(searchTerm);
                    nodes.update({ id: node.id, hidden: !matches });
                });
            });
        }
        
        // Setup filter buttons
        function setupFilters(network, nodes, edges) {
            const btnAll = document.getElementById('filter-all');
            const btnMac = document.getElementById('filter-mac');
            const btnIp = document.getElementById('filter-ip');
            
            btnAll.addEventListener('click', function() {
                // Show all nodes
                nodes.forEach(node => {
                    nodes.update({ id: node.id, hidden: false });
                });
                
                // Update button styles
                updateFilterButtonStyles(btnAll);
            });
            
            btnMac.addEventListener('click', function() {
                // Show MAC nodes, hide IP nodes
                nodes.forEach(node => {
                    const isMac = node.group === 'mac';
                    nodes.update({ id: node.id, hidden: !isMac });
                });
                
                // Update button styles
                updateFilterButtonStyles(btnMac);
            });
            
            btnIp.addEventListener('click', function() {
                // Show IP nodes, hide MAC nodes
                nodes.forEach(node => {
                    const isIp = node.group === 'ip';
                    nodes.update({ id: node.id, hidden: !isIp });
                });
                
                // Update button styles
                updateFilterButtonStyles(btnIp);
            });
            
            function updateFilterButtonStyles(activeButton) {
                // Reset all button styles
                [btnAll, btnMac, btnIp].forEach(btn => {
                    btn.classList.remove('bg-primary', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-800');
                });
                
                // Set active button style
                activeButton.classList.remove('bg-gray-200', 'text-gray-800');
                activeButton.classList.add('bg-primary', 'text-white');
            }
        }
        
        // Setup layout buttons
        function setupLayouts(network) {
            if (!network) {
                console.warn("Network is not initialized in setupLayouts");
                return;
            }
            
            const btnHierarchical = document.getElementById('layout-hierarchical');
            const btnPhysics = document.getElementById('layout-physics');
            
            // Hierarchical button handler
            btnHierarchical.addEventListener('click', function() {
                // Update button styles first
                updateLayoutButtonStyles(btnHierarchical);
                
                console.log("Switching to Hierarchical view");
                
                // Explicitly enable hierarchical layout and disable physics
                network.setOptions({
                    physics: { 
                        enabled: false 
                    },
                    layout: {
                        hierarchical: {
                            enabled: true,  // Explicitly enable hierarchical layout
                            direction: 'LR',
                            sortMethod: 'directed',
                            nodeSpacing: 250,         // Increased node spacing
                            levelSeparation: 300,     // Increased level separation
                            treeSpacing: 200          // Added tree spacing
                        }
                    }
                });
            });
            
            // Force Directed button handler
            btnPhysics.addEventListener('click', function() {
                // Update button styles first
                updateLayoutButtonStyles(btnPhysics);
                
                console.log("Switching to Disjoint Force-Directed view");
                
                if (!network) {
                    console.warn("Network is not properly initialized");
                    return;
                }
                
                // First disable hierarchical layout explicitly, then enable physics
                network.setOptions({
                    layout: { 
                        hierarchical: { 
                            enabled: false  // Explicitly disable hierarchical layout
                        } 
                    }
                });
                
                // Separate call to enable physics with D3-style configuration
                network.setOptions({
                    physics: {
                        enabled: true,
                        // D3-style physics configuration exactly matching the demo
                        barnesHut: {
                            gravitationalConstant: -200,      // Match the demo's forceManyBody().strength(-200)
                            centralGravity: 0.01,             // Very weak central gravity like in D3
                            springLength: 200,                // Match the demo's forceLink().distance(200)
                            springConstant: 0.04,             // Moderate spring constant
                            damping: 0.09,
                            avoidOverlap: 1.0                 // Maximum avoidance (d3.forceCollide)
                        },
                        solver: 'barnesHut',
                        stabilization: {
                            enabled: true,
                            iterations: 100,                  // Fewer iterations like in the demo
                            updateInterval: 25,
                            onlyDynamicEdges: false,
                            fit: false                        // Don't fit to view to preserve positions
                        },
                        timestep: 0.5,                        // Like in the demo
                        adaptiveTimestep: true
                    }
                });
                
                // Apply collision handling after a short delay to let physics start
                setTimeout(function() {
                    if (network) {
                        try {
                            applyCollisionHandling();
                            updateEdgesWithTypeStyles(); // Apply edge styles to match the demo
                            
                            // After initial layout, set a more stable physics config
                            setTimeout(function() {
                                if (network) {
                                    network.setOptions({
                                        physics: {
                                            enabled: true,
                                            barnesHut: {
                                                gravitationalConstant: -200,
                                                centralGravity: 0.02,  // Slight increase for stability
                                                springLength: 200,
                                                springConstant: 0.04,
                                                avoidOverlap: 1.0
                                            },
                                            timestep: 0.3,         // Reduced timestep for stability
                                            maxVelocity: 10        // Lower velocity after initial layout
                                        }
                                    });
                                }
                            }, 3000);
                        } catch (error) {
                            console.error("Error applying disjoint force-directed layout:", error);
                        }
                    }
                }, 1000);
            });
            
            function updateLayoutButtonStyles(activeButton) {
                // Reset all button styles
                [btnHierarchical, btnPhysics].forEach(btn => {
                    btn.classList.remove('bg-primary', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-800');
                });
                
                // Set active button style
                activeButton.classList.remove('bg-gray-200', 'text-gray-800');
                activeButton.classList.add('bg-primary', 'text-white');
            }
            
            // Helper function to apply D3-style collision handling and boundary forces
            function applyCollisionHandling() {
                if (!network || typeof network.getNodeIds !== 'function') {
                    console.warn("Network is not properly initialized or doesn't have getNodeIds method");
                    return;
                }
                
                try {
                    const nodeIds = network.getNodeIds();
                    if (!nodeIds || nodeIds.length === 0) {
                        console.warn("No nodes to apply collision handling to");
                        return;
                    }
                    
                    const positions = network.getPositions(nodeIds);
                    const containerRect = document.getElementById('network-container').getBoundingClientRect();
                    
                    // Get dimensions to apply boundary constraints
                    const width = containerRect.width;
                    const height = containerRect.height;
                    const nodeRadius = 25;
                    const forcePadding = nodeRadius + 10; // Same as in the demo

                    console.log("Applying D3-style collision handling to", nodeIds.length, "nodes");
                    
                    // Apply container boundary constraints
                    nodeIds.forEach(nodeId => {
                        const pos = positions[nodeId];
                        if (!pos) return;
                        
                        // Apply boundary constraints exactly like in the demo's transform function
                        let x = pos.x;
                        let y = pos.y;
                        
                        x = x <= forcePadding ? forcePadding : 
                            x >= width - forcePadding ? width - forcePadding : x;
                        y = y <= forcePadding ? forcePadding : 
                            y >= height - forcePadding ? height - forcePadding : y;
                        
                        // Move node if position changed
                        if (x !== pos.x || y !== pos.y) {
                            network.moveNode(nodeId, x, y);
                        }
                    });
                    
                    // Enhance collision handling for overlapping nodes
                    network.setOptions({
                        physics: {
                            barnesHut: {
                                avoidOverlap: 1.0,
                                gravitationalConstant: -200,  // Match exactly the demo's force settings
                                springLength: 200,            // Match the demo's distance
                                springConstant: 0.04,
                                centralGravity: 0.01          // Very weak central gravity like in D3
                            }
                        }
                    });
                    
                    // Add extra force application to spread nodes - similar to D3 demo
                    setTimeout(() => {
                        if (network) {
                            // Apply a slight outward force from center
                            const center = {
                                x: width / 2,
                                y: height / 2
                            };
                            
                            nodeIds.forEach(nodeId => {
                                const pos = network.getPositions([nodeId])[nodeId];
                                if (!pos) return;
                                
                                // Calculate vector from center to node
                                const dx = pos.x - center.x;
                                const dy = pos.y - center.y;
                                
                                // Calculate distance from center
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance > 0) {
                                    // Normalize vector
                                    const nx = dx / distance;
                                    const ny = dy / distance;
                                    
                                    // Apply a small outward force
                                    const forceMagnitude = 10;
                                    network.moveNode(nodeId, pos.x + nx * forceMagnitude, pos.y + ny * forceMagnitude);
                                }
                            });
                        }
                    }, 1500);
                } catch (error) {
                    console.error("Error in applyCollisionHandling:", error);
                }
            }
        }
        
        // Setup action buttons
        function setupActionButtons(network, container) {
            const btnFullscreen = document.getElementById('btn-fullscreen');
            const btnExport = document.getElementById('btn-export');
            
            btnFullscreen.addEventListener('click', function() {
                // Use the visualization-container for fullscreen
                const visualizationContainer = document.getElementById('network-container');
                if (!document.fullscreenElement) {
                    visualizationContainer.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable fullscreen: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            });
            
            btnExport.addEventListener('click', function() {
                // Export the current network view as an image
                const networkContainer = document.getElementById('network-container');
                if (networkContainer) {
                    html2canvas(networkContainer).then(canvas => {
                        const imageData = canvas.toDataURL('image/png');
                        const link = document.createElement('a');
                        link.href = imageData;
                        link.download = `network_visualization_${Date.now()}.png`;
                        link.click();
                    });
                }
            });
        }
        
        // Fix: Update the resize function to use the correct container
        function resizeNetwork() {
            if (network && typeof network.setSize === 'function') {
                // Calculate available height
                const headerHeight = document.querySelector('header').offsetHeight;
                const controlsHeight = document.querySelector('.compact-controls').offsetHeight;
                const legendHeight = document.querySelector('.compact-legend').offsetHeight;
                const footerHeight = document.querySelector('footer').offsetHeight;
                const spacing = 30; // Extra spacing/margins
                
                // Calculate available height
                const availableHeight = window.innerHeight - headerHeight - controlsHeight - legendHeight - footerHeight - spacing;
                
                // Set visualization container height
                const visualizationContainer = document.getElementById('network-container');
                visualizationContainer.style.height = `${availableHeight}px`;
                
                // Update network size
                network.setSize('100%', '100%');
                network.redraw();
            } else {
                console.warn("Network is not properly initialized or doesn't have setSize method");
            }
        }
        
        // Call resize on load and window resize
        window.addEventListener('resize', resizeNetwork);

        // Add connection type styling like in the demo
        function updateEdgesWithTypeStyles() {
            if (!allEdges || typeof allEdges.getIds !== 'function') {
                console.warn("allEdges is not properly initialized or doesn't have getIds method");
                return;
            }
            
            try {
                // Make sure we have edges before proceeding - check edge count properly
                if (allEdges.get().length === 0) {
                    console.warn("No edges to style");
                    return;
                }

                const edgeIds = allEdges.getIds();
                const updatedEdges = [];
                
                edgeIds.forEach(id => {
                    const edge = allEdges.get(id);
                    let edgeStyle = {};
                    
                    // Set edge label based on connection type like in the demo
                    // Extract the connection type from the title
                    let label = '';
                    if (edge.title) {
                        if (edge.title.includes("Accepted")) {
                            label = 'request-accepted';
                        } else if (edge.title.includes("Response")) {
                            label = 'response';
                        } else if (edge.title.includes("Rejected")) {
                            label = 'request-rejected';
                        }
                    }
                    
                    // Set color and style based on connection type exactly like the demo
                    if (edge.title && edge.title.includes("Accepted")) {
                        edgeStyle = {
                            id: id,
                            label: label,
                            font: {
                                size: 10,
                                face: 'Roboto Condensed',
                                color: '#66c2a5',
                                strokeWidth: 4,
                                strokeColor: '#ffffff',
                                align: 'middle'
                            },
                            color: { color: '#66c2a5', highlight: '#66c2a5', hover: '#66c2a5' }, // Same green color as demo
                            arrows: { to: { enabled: true } }
                        };
                    } else if (edge.title && edge.title.includes("Response")) {
                        edgeStyle = {
                            id: id,
                            label: label,
                            font: {
                                size: 10,
                                face: 'Roboto Condensed',
                                color: '#8da0cb',
                                strokeWidth: 4,
                                strokeColor: '#ffffff',
                                align: 'middle'
                            },
                            color: { color: '#8da0cb', highlight: '#8da0cb', hover: '#8da0cb' }, // Same blue color as demo
                            dashes: [2, 2], // Use dashed lines for response edges like the demo
                            arrows: { to: { enabled: true } }
                        };
                    } else if (edge.title && edge.title.includes("Rejected")) {
                        edgeStyle = {
                            id: id,
                            label: label,
                            font: {
                                size: 10,
                                face: 'Roboto Condensed',
                                color: '#fc8d62',
                                strokeWidth: 4,
                                strokeColor: '#ffffff',
                                align: 'middle'
                            },
                            color: { color: '#fc8d62', highlight: '#fc8d62', hover: '#fc8d62' }, // Same orange/red color as demo
                            arrows: { to: { enabled: true } }
                        };
                    } else {
                        // Default style for other connections
                        edgeStyle = {
                            id: id,
                            label: '',
                            color: { color: '#666', highlight: '#444', hover: '#444' },
                            arrows: { to: { enabled: true } }
                        };
                    }
                    
                    updatedEdges.push(edgeStyle);
                });
                
                // Update all edges at once for better performance
                allEdges.update(updatedEdges);
            } catch (error) {
                console.error("Error in updateEdgesWithTypeStyles:", error);
            }
        }
    });
</script>

<script>
  document.addEventListener("DOMContentLoaded", function() {
    const btnPhysics = document.getElementById('layout-physics');
    
    // Create a function to check if network is ready and then apply the layout
    function tryApplyDefaultLayout() {
        if (network && typeof network.setOptions === 'function') {
            console.log("Network is ready, applying default layout");
            if (btnPhysics) {
                // Make sure to handle any errors during default layout application
                try {
                    btnPhysics.click();
                } catch (error) {
                    console.error("Error applying default layout:", error);
                }
            }
        } else {
            console.log("Waiting for network to initialize...");
            // Limit retry attempts to avoid infinite loop
            if (window.networkInitAttempts === undefined) {
                window.networkInitAttempts = 0;
            }
            window.networkInitAttempts++;
            
            if (window.networkInitAttempts < 20) { // Limit to 10 seconds (20 * 500ms)
                setTimeout(tryApplyDefaultLayout, 500);
            } else {
                console.error("Failed to initialize network after multiple attempts");
            }
        }
    }
    
    // Start checking after a delay to allow for initial page load
    setTimeout(tryApplyDefaultLayout, 1000);
  });
</script>
{% endblock %} 