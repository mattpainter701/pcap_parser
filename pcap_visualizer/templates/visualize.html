{% extends "base.html" %}

{# Set full width flag for this template #}
{% set full_width = True %}

{% block title %}Network Visualization - {{ filename }}{% endblock %}

{% block head %}
<!-- Use local vis.js instead of CDN -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
<style>
    @import url("https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700");
    
    #network-container {
        width: 100vw;
        /* Calculate height to leave room for other elements */
        height: calc(100vh - 400px); /* Reduced height to fit everything on screen */
        border: 1px solid #ddd;
        background-color: #f8fafc;
        border-radius: 0;
        margin-left: calc(-50vw + 50%);
        margin-right: calc(-50vw + 50%);
        position: relative;
        overflow: hidden; /* Prevent scrollbars within container */
    }
    
    .control-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 12px;
        z-index: 10;
        width: 250px;
    }
    
    .node-tooltip {
        background-color: white;
        padding: 8px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        font-size: 12px;
    }
    
    .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
    }
    
    .legend-color {
        width: 12px;
        height: 12px;
        margin-right: 5px;
        border-radius: 2px;
    }
    
    /* Make controls container full width but with padding */
    .controls-container {
        padding: 0 1rem;
        width: 100%;
        max-width: 100%;
    }
    
    /* More compact spacing */
    .compact-controls {
        margin-bottom: 0.75rem;
        padding: 0.75rem;
    }
    
    .compact-legend {
        margin-top: 0.75rem;
        padding: 0.5rem 1rem;
    }
</style>
{% endblock %}

{% block content %}
<!-- Make header more compact -->
<div class="controls-container mb-2 flex justify-between items-center">
    <div>
        <h2 class="text-xl font-bold text-gray-800">
            <i class="fas fa-project-diagram mr-2 text-primary"></i> 
            Network Visualization: {{ filename }}
        </h2>
    </div>
    <a href="{{ url_for('index') }}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-1 px-3 rounded-md inline-flex items-center transition-colors text-sm">
        <i class="fas fa-arrow-left mr-2"></i> Back
    </a>
</div>

<!-- Make controls more compact -->
<div class="controls-container bg-white rounded-lg shadow-md p-3 mb-3 compact-controls">
    <div class="flex flex-wrap gap-2 mb-2">
        <!-- Search box -->
        <div class="flex-grow max-w-md">
            <div class="relative">
                <input type="text" id="search-input" class="w-full pl-10 pr-4 py-2 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Search nodes...">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <i class="fas fa-search text-gray-400"></i>
                </div>
            </div>
        </div>
        
        <!-- Filter buttons -->
        <div class="flex space-x-2">
            <button id="filter-all" class="bg-primary text-white py-2 px-4 rounded-md hover:bg-opacity-90 transition-colors">
                <i class="fas fa-globe-americas mr-1"></i> All
            </button>
            <button id="filter-mac" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-network-wired mr-1"></i> MAC
            </button>
            <button id="filter-ip" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-sitemap mr-1"></i> IP
            </button>
        </div>
    </div>
    
    <div class="flex flex-wrap gap-2">
        <!-- Layout controls -->
        <div class="flex space-x-2">
            <button id="layout-hierarchical" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-sitemap mr-1"></i> Hierarchical
            </button>
            <button id="layout-physics" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-atom mr-1"></i> Disjoint Force-Directed
            </button>
        </div>
        
        <!-- Action buttons -->
        <div class="flex space-x-2 ml-auto">
            <button id="btn-fullscreen" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-expand mr-1"></i> Fullscreen
            </button>
            <button id="btn-export" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-download mr-1"></i> Export
            </button>
        </div>
    </div>
</div>

<!-- Fix the visualization container structure to match JavaScript expectations -->
<div id="network-container">
    <!-- Add search box -->
    <div class="search-box">
        <input type="text" id="search-input" placeholder="Search by IP or MAC">
        <button id="search-button">Search</button>
    </div>
    <div id="network"></div>
</div>

<!-- Simplified and more compact legend -->
<div class="controls-container flex items-center bg-white rounded-lg shadow-md compact-legend">
    <span class="text-sm font-medium text-gray-700 mr-3">Legend:</span>
    <div class="legend">
        <div class="legend-item mr-4">
            <div class="legend-color" style="background-color: #4f46e5;"></div>
            <span class="text-xs">MAC Address</span>
        </div>
        <div class="legend-item mr-4">
            <div class="legend-color" style="background-color: #10b981;"></div>
            <span class="text-xs">IP Address</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #000; height: 2px;"></div>
            <span class="text-xs">Connection</span>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Use local vis.js instead of CDN -->
<script src="{{ url_for('static', filename='js/vis-network-bundle.js') }}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize datasets - use empty arrays initially
        let allNodes = null; 
        let allEdges = null;
        let network = null;
        
        // Make these variables globally accessible
        window.allNodes = allNodes;
        window.allEdges = allEdges;
        window.network = network;
        
        // Fix: Get the correct container element
        const container = document.getElementById('network');
        if (!container) {
            console.error("Network container element not found");
            return;
        }
        
        // Load the network data from the API first
        console.log("Fetching network data for {{ filename }}");
        fetch(`/api/network_data/{{ filename }}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Received network data:", data);
                
                try {
                    if (!data || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
                        console.error("Invalid data format:", data);
                        throw new Error("Invalid data format received from server");
                    }
                    
                    // IMPORTANT: Create new DataSet objects with the data
                    window.allNodes = new vis.DataSet(data.nodes);
                    window.allEdges = new vis.DataSet(data.edges);
                    
                    // Define different node groups with distinctive styles
                    const groups = {
                        mac: {
                            color: {
                                background: '#ddd',
                                border: '#666',
                                highlight: {
                                    background: '#ccc',
                                    border: '#444'
                                }
                            },
                            font: {
                                color: '#000000',
                                size: 10,
                                face: 'Roboto Condensed'
                            },
                            borderWidth: 1,
                            shape: 'circle',
                            size: 25
                        },
                        ip: {
                            color: {
                                background: '#ddd',
                                border: '#666',
                                highlight: {
                                    background: '#ccc',
                                    border: '#444'
                                }
                            },
                            font: {
                                color: '#000000',
                                size: 10,
                                face: 'Roboto Condensed'
                            },
                            borderWidth: 1,
                            shape: 'circle',
                            size: 25,
                            margin: 10
                        }
                    };
                    
                    // Edge styling
                    const edgesOptions = {
                        color: {
                            color: '#666',
                            highlight: '#444',
                            hover: '#444'
                        },
                        width: 1.5,
                        font: {
                            align: 'middle',
                            size: 10,
                            face: 'Roboto Condensed',
                            strokeWidth: 4,
                            strokeColor: '#ffffff'
                        },
                        selectionWidth: 2,
                        smooth: {
                            type: 'straightCross',
                            roundness: 0
                        }
                    };
                    
                    // Network visualization options
                    const options = {
                        nodes: {
                            font: {
                                size: 12,
                                face: 'Roboto'
                            },
                            margin: 10,
                            shape: 'box',
                            scaling: {
                                min: 16,
                                max: 32
                            }
                        },
                        edges: edgesOptions,
                        groups: groups,
                        physics: {
                            enabled: true,
                            barnesHut: {
                                gravitationalConstant: -2000,
                                centralGravity: 0.01,
                                springLength: 200,
                                springConstant: 0.04,
                                damping: 0.09,
                                avoidOverlap: 1.0
                            },
                            solver: 'barnesHut',
                            stabilization: {
                                enabled: true,
                                iterations: 250,
                                updateInterval: 25,
                                onlyDynamicEdges: false,
                                fit: true
                            },
                            timestep: 0.3,
                            adaptiveTimestep: true,
                            maxVelocity: 50,
                            minVelocity: 0.15
                        },
                        interaction: {
                            hover: true,
                            tooltipDelay: 200,
                            navigationButtons: true,
                            keyboard: true,
                            zoomView: true
                        },
                        layout: {
                            randomSeed: 1,
                            improvedLayout: true,
                            clusterThreshold: 150
                        }
                    };

                    // Create network data with proper DataSet objects
                    const networkData = {
                        nodes: window.allNodes,
                        edges: window.allEdges
                    };
                    
                    console.log(`Creating network with ${window.allNodes.length} nodes and ${window.allEdges.length} edges`);
                    
                    // Initialize the network
                    window.network = new vis.Network(container, networkData, options);
                    console.log("Network initialized successfully");
                    
                    // Setup event handlers
                    setupNetworkEvents();
                    
                    // Apply the default layout after a short delay
                    setTimeout(() => {
                        const btnPhysics = document.getElementById('layout-physics');
                        if (btnPhysics) {
                            btnPhysics.click();
                        }
                    }, 500);
                    
                } catch (err) {
                    console.error("Error setting up network data:", err);
                    container.innerHTML = `
                        <div class="flex flex-col items-center justify-center h-full p-4">
                            <div class="text-red-500 text-xl mb-4">❌ Error Loading Visualization</div>
                            <div class="text-gray-700 mb-2">${err.message}</div>
                            <div class="text-gray-500 text-sm">Please check the console for more details.</div>
                        </div>
                    `;
                }
            })
            .catch(error => {
                console.error("Error fetching network data:", error);
                container.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-full p-4">
                        <div class="text-red-500 text-xl mb-4">❌ Error Loading Data</div>
                        <div class="text-gray-700 mb-2">${error.message}</div>
                        <div class="text-gray-500 text-sm">Please check that the file exists and is in the correct format.</div>
                    </div>
                `;
            });
            
        // Setup all network event handlers
        function setupNetworkEvents() {
            if (!window.network) {
                console.error("Cannot setup events: network not initialized");
                return;
            }
            
            // Double-click event
            window.network.on("doubleClick", function(params) {
                if (params.nodes && params.nodes.length > 0) {
                    // Focus on the selected node
                    window.network.focus(params.nodes[0], {
                        scale: 1.2,
                        animation: true
                    });
                }
            });
            
            // Stabilization complete event
            window.network.once("stabilizationIterationsDone", function() {
                console.log("Network stabilized");
                
                // Safely check if methods exist before calling them
                if (window.network && typeof window.network.getNodeIds === 'function') {
                    // Apply a final layout adjustment to spread nodes further
                    applyFinalLayoutAdjustment();
                } else {
                    console.warn("Network is not properly initialized or doesn't have getNodeIds method");
                }
                
                // Make sure to call resize after stabilization
                setTimeout(resizeNetwork, 100);
            });
            
            // Add search functionality
            const searchButton = document.getElementById('search-button');
            const searchInput = document.getElementById('search-input');
            
            if (searchButton) {
                searchButton.addEventListener('click', performSearch);
            }
            
            if (searchInput) {
                searchInput.addEventListener('keyup', function(event) {
                    if (event.key === "Enter") {
                        performSearch();
                    }
                });
            }
            
            // Handle layout changes
            const layoutHierarchicalBtn = document.getElementById('layout-hierarchical');
            const layoutPhysicsBtn = document.getElementById('layout-physics');
            
            if (layoutHierarchicalBtn) {
                layoutHierarchicalBtn.addEventListener('click', function() {
                    if (!window.network) return;
                    applyHierarchicalLayout();
                });
            }
            
            if (layoutPhysicsBtn) {
                layoutPhysicsBtn.addEventListener('click', function() {
                    if (!window.network) return;
                    applyForceDirectedLayout();
                });
            }
            
            // Handle fullscreen button
            const fullscreenBtn = document.getElementById('btn-fullscreen');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', function() {
                    const container = document.getElementById('network-container');
                    if (!container) return;
                    
                    if (!document.fullscreenElement) {
                        if (container.requestFullscreen) {
                            container.requestFullscreen();
                        } else if (container.mozRequestFullScreen) {
                            container.mozRequestFullScreen();
                        } else if (container.webkitRequestFullscreen) {
                            container.webkitRequestFullscreen();
                        } else if (container.msRequestFullscreen) {
                            container.msRequestFullscreen();
                        }
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        }
                    }
                });
            }
            
            // Handle window resize event
            window.addEventListener('resize', function() {
                resizeNetwork();
            });
            
            // Listen for fullscreen change to resize network
            document.addEventListener('fullscreenchange', resizeNetwork);
            document.addEventListener('webkitfullscreenchange', resizeNetwork);
            document.addEventListener('mozfullscreenchange', resizeNetwork);
            document.addEventListener('MSFullscreenChange', resizeNetwork);
        }
        
        // Apply final layout adjustments to improve node placement
        function applyFinalLayoutAdjustment() {
            if (!window.network || typeof window.network.getNodeIds !== 'function') {
                console.warn("Cannot apply layout adjustment: network methods not available");
                return;
            }
            
            try {
                const nodeIds = window.network.getNodeIds();
                if (!nodeIds || !nodeIds.length) {
                    console.warn("No nodes found for layout adjustment");
                    return;
                }
                
                const positions = window.network.getPositions(nodeIds);
                
                // Group nodes by type
                const ipNodes = window.allNodes.get().filter(node => node.group === 'ip').map(node => node.id);
                const macNodes = window.allNodes.get().filter(node => node.group === 'mac').map(node => node.id);
                
                // Scale positions outward by different factors based on node type
                for (const nodeId of nodeIds) {
                    const pos = positions[nodeId];
                    if (!pos) continue;
                    
                    if (ipNodes.includes(nodeId)) {
                        // IP nodes get expanded more (40% scaling)
                        window.network.moveNode(nodeId, pos.x * 1.4, pos.y * 1.4);
                    } else {
                        // MAC nodes get normal expansion (20% scaling)
                        window.network.moveNode(nodeId, pos.x * 1.2, pos.y * 1.2);
                    }
                }
                
                // Disable physics after stabilization
                window.network.setOptions({ physics: { enabled: false } });
                
                console.log("Applied final layout adjustment");
            } catch (err) {
                console.error("Error applying layout adjustment:", err);
            }
        }
        
        // Perform search on node data
        function performSearch() {
            if (!window.network || typeof window.network.getNodeIds !== 'function' || !window.allNodes) {
                console.warn("Search functionality unavailable: network not properly initialized");
                return;
            }
            
            const searchInput = document.getElementById('search-input');
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.trim().toLowerCase();
            if (!searchTerm) return;
            
            console.log("Searching for:", searchTerm);
            
            try {
                // Get all nodes
                const nodeIds = window.network.getNodeIds();
                const foundNodes = [];
                
                // Search through nodes
                nodeIds.forEach(id => {
                    const node = window.allNodes.get(id);
                    if (node && node.label && node.label.toLowerCase().includes(searchTerm)) {
                        foundNodes.push(id);
                    }
                });
                
                if (foundNodes.length > 0) {
                    // Focus on the first match
                    window.network.focus(foundNodes[0], {
                        scale: 1.2,
                        animation: true
                    });
                    window.network.selectNodes(foundNodes);
                    
                    // Highlight the found nodes
                    const updatedNodes = foundNodes.map(id => {
                        const node = window.allNodes.get(id);
                        if (!node) return null;
                        
                        const originalColor = node.color ? { ...node.color } : null;
                        
                        return {
                            id: id,
                            color: {
                                background: '#FFFF00',
                                border: '#FFA500',
                                highlight: {
                                    background: '#FFFF00',
                                    border: '#FFA500'
                                },
                                _originalColor: originalColor
                            }
                        };
                    }).filter(node => node !== null);
                    
                    window.allNodes.update(updatedNodes);
                    
                    // Reset highlight after a delay
                    setTimeout(() => {
                        const resetNodes = foundNodes.map(id => {
                            const node = window.allNodes.get(id);
                            if (!node) return null;
                            
                            return {
                                id: id,
                                color: node.color._originalColor
                            };
                        }).filter(node => node !== null);
                        
                        window.allNodes.update(resetNodes);
                    }, 3000);
                    
                    console.log(`Found ${foundNodes.length} nodes matching "${searchTerm}"`);
                } else {
                    console.log(`No nodes found matching "${searchTerm}"`);
                    alert(`No nodes found matching "${searchTerm}"`);
                }
            } catch (err) {
                console.error("Error during search:", err);
            }
        }
        
        // Apply hierarchical layout
        function applyHierarchicalLayout() {
            if (!window.network) return;
            
            console.log("Switching to Hierarchical view");
            
            try {
                // Set up hierarchical layout
                window.network.setOptions({
                    layout: {
                        hierarchical: {
                            direction: 'UD',
                            sortMethod: 'directed',
                            nodeSpacing: 150,
                            treeSpacing: 200
                        }
                    },
                    physics: {
                        enabled: true,
                        hierarchicalRepulsion: {
                            centralGravity: 0.2,
                            springLength: 150,
                            springConstant: 0.01,
                            nodeDistance: 120,
                            damping: 0.09
                        },
                        solver: 'hierarchicalRepulsion',
                        stabilization: {
                            enabled: true,
                            iterations: 1000,
                            updateInterval: 100
                        }
                    }
                });
                
                // Highlight the active button
                document.getElementById('layout-hierarchical').classList.remove('bg-gray-200');
                document.getElementById('layout-hierarchical').classList.add('bg-primary', 'text-white');
                document.getElementById('layout-physics').classList.remove('bg-primary', 'text-white');
                document.getElementById('layout-physics').classList.add('bg-gray-200', 'text-gray-800');
            } catch (err) {
                console.error("Error applying hierarchical layout:", err);
            }
        }
        
        // Apply force-directed layout
        function applyForceDirectedLayout() {
            if (!window.network) return;
            
            console.log("Switching to Disjoint Force-Directed view");
            
            try {
                // Disable hierarchical layout and apply force-directed
                window.network.setOptions({
                    layout: {
                        hierarchical: false,
                        improvedLayout: true
                    },
                    physics: {
                        enabled: true,
                        barnesHut: {
                            gravitationalConstant: -2000,
                            centralGravity: 0.3,
                            springLength: 150,
                            springConstant: 0.04,
                            damping: 0.09,
                            avoidOverlap: 1.0
                        },
                        solver: 'barnesHut',
                        stabilization: {
                            enabled: true,
                            iterations: 1000,
                            updateInterval: 100
                        }
                    }
                });
                
                // Highlight the active button
                document.getElementById('layout-physics').classList.remove('bg-gray-200');
                document.getElementById('layout-physics').classList.add('bg-primary', 'text-white');
                document.getElementById('layout-hierarchical').classList.remove('bg-primary', 'text-white');
                document.getElementById('layout-hierarchical').classList.add('bg-gray-200', 'text-gray-800');
                
                // Apply force-directed layout
                console.log("Rendering force-directed layout");
                
                // Force a redraw instead of startSimulation (which doesn't exist)
                if (window.network) {
                    try {
                        window.network.redraw();
                        // Re-enable physics which will start the simulation
                        window.network.setOptions({ physics: { enabled: true } });
                    } catch (err) {
                        console.error("Error redrawing network:", err);
                    }
                }
            } catch (err) {
                console.error("Error applying force-directed layout:", err);
            }
        }
        
        // Handle window resize
        function resizeNetwork() {
            if (!window.network || typeof window.network.setSize !== 'function') {
                console.warn("Network is not properly initialized or doesn't have setSize method");
                return;
            }
            
            const container = document.getElementById('network-container');
            if (!container) return;
            
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            
            if (width > 0 && height > 0) {
                try {
                    window.network.setSize(`${width}px`, `${height}px`);
                    window.network.fit();
                } catch (err) {
                    console.error("Error resizing network:", err);
                }
            }
        }
    });
</script>
{% endblock %} 