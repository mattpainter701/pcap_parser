{% extends "base.html" %}

{# Set full width flag for this template #}
{% set full_width = True %}

{% block title %}Network Visualization - {{ filename }}{% endblock %}

{% block head %}
<!-- Use local vis.js instead of CDN -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
<style>
    #network-container {
        width: 100vw;
        /* Calculate height to leave room for other elements */
        height: calc(100vh - 400px); /* Reduced height to fit everything on screen */
        border: 1px solid #ddd;
        background-color: #f8fafc;
        border-radius: 0;
        margin-left: calc(-50vw + 50%);
        margin-right: calc(-50vw + 50%);
        position: relative;
        overflow: hidden; /* Prevent scrollbars within container */
    }
    
    .control-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 12px;
        z-index: 10;
        width: 250px;
    }
    
    .node-tooltip {
        background-color: white;
        padding: 8px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        font-size: 12px;
    }
    
    .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
    }
    
    .legend-color {
        width: 12px;
        height: 12px;
        margin-right: 5px;
        border-radius: 2px;
    }
    
    /* Make controls container full width but with padding */
    .controls-container {
        padding: 0 1rem;
        width: 100%;
        max-width: 100%;
    }
    
    /* More compact spacing */
    .compact-controls {
        margin-bottom: 0.75rem;
        padding: 0.75rem;
    }
    
    .compact-legend {
        margin-top: 0.75rem;
        padding: 0.5rem 1rem;
    }
</style>
{% endblock %}

{% block content %}
<!-- Make header more compact -->
<div class="controls-container mb-2 flex justify-between items-center">
    <div>
        <h2 class="text-xl font-bold text-gray-800">
            <i class="fas fa-project-diagram mr-2 text-primary"></i> 
            Network Visualization: {{ filename }}
        </h2>
    </div>
    <a href="{{ url_for('index') }}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-1 px-3 rounded-md inline-flex items-center transition-colors text-sm">
        <i class="fas fa-arrow-left mr-2"></i> Back
    </a>
</div>

<!-- Make controls more compact -->
<div class="controls-container bg-white rounded-lg shadow-md p-3 mb-3 compact-controls">
    <div class="flex flex-wrap gap-2 mb-2">
        <!-- Search box -->
        <div class="flex-grow max-w-md">
            <div class="relative">
                <input type="text" id="search-input" class="w-full pl-10 pr-4 py-2 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Search nodes...">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <i class="fas fa-search text-gray-400"></i>
                </div>
            </div>
        </div>
        
        <!-- Filter buttons -->
        <div class="flex space-x-2">
            <button id="filter-all" class="bg-primary text-white py-2 px-4 rounded-md hover:bg-opacity-90 transition-colors">
                <i class="fas fa-globe-americas mr-1"></i> All
            </button>
            <button id="filter-mac" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-network-wired mr-1"></i> MAC
            </button>
            <button id="filter-ip" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-sitemap mr-1"></i> IP
            </button>
        </div>
    </div>
    
    <div class="flex flex-wrap gap-2">
        <!-- Layout controls -->
        <div class="flex space-x-2">
            <button id="layout-hierarchical" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-sitemap mr-1"></i> Hierarchical
            </button>
            <button id="layout-physics" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-atom mr-1"></i> Force Directed
            </button>
        </div>
        
        <!-- Action buttons -->
        <div class="flex space-x-2 ml-auto">
            <button id="btn-fullscreen" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-expand mr-1"></i> Fullscreen
            </button>
            <button id="btn-export" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">
                <i class="fas fa-download mr-1"></i> Export
            </button>
        </div>
    </div>
</div>

<!-- Fix the visualization container structure to match JavaScript expectations -->
<div id="network-container">
    <!-- Add search box -->
    <div class="search-box">
        <input type="text" id="search-input" placeholder="Search by IP or MAC">
        <button id="search-button">Search</button>
    </div>
    <div id="network"></div>
</div>

<!-- Simplified and more compact legend -->
<div class="controls-container flex items-center bg-white rounded-lg shadow-md compact-legend">
    <span class="text-sm font-medium text-gray-700 mr-3">Legend:</span>
    <div class="legend">
        <div class="legend-item mr-4">
            <div class="legend-color" style="background-color: #4f46e5;"></div>
            <span class="text-xs">MAC Address</span>
        </div>
        <div class="legend-item mr-4">
            <div class="legend-color" style="background-color: #10b981;"></div>
            <span class="text-xs">IP Address</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #000; height: 2px;"></div>
            <span class="text-xs">Connection</span>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Use local vis.js instead of CDN -->
<script src="{{ url_for('static', filename='js/vis-network-bundle.js') }}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Fix: Get the correct container element
        const container = document.getElementById('network');
        let network = null;
        let allNodes = [];
        let allEdges = [];
        
        // Define different node groups with distinctive styles
        const groups = {
            mac: {
                color: {
                    background: '#4f46e5',
                    border: '#3730a3',
                    highlight: {
                        background: '#818cf8',
                        border: '#4f46e5'
                    }
                },
                font: {
                    color: '#ffffff'
                },
                borderWidth: 2,
                shape: 'box'
            },
            ip: {
                color: {
                    background: '#10b981',
                    border: '#047857',
                    highlight: {
                        background: '#34d399',
                        border: '#10b981'
                    }
                },
                font: {
                    color: '#ffffff'
                },
                borderWidth: 2,
                shape: 'ellipse',          // Changed from 'dot' to 'ellipse' for better visibility
                size: 20,                  // Larger size for IP nodes
                margin: 15                 // More margin around text
            }
        };
        
        // Edge styling
        const edgesOptions = {
            color: {
                color: '#64748b',
                highlight: '#334155',
                hover: '#334155'
            },
            font: {
                align: 'middle',
                size: 10
            },
            selectionWidth: 2,
            smooth: {
                type: 'continuous',
                roundness: 0.2
            }
        };
        
        // Network visualization options
        const options = {
            nodes: {
                font: {
                    size: 12,
                    face: 'Roboto'
                },
                margin: 10,
                shape: 'box',
                scaling: {
                    min: 16,
                    max: 32
                }
            },
            edges: edgesOptions,
            groups: groups,
            physics: {
                enabled: true,
                // D3-style physics configuration as default
                barnesHut: {
                    gravitationalConstant: -2000,     // Similar to d3.forceManyBody().strength(-200)
                    centralGravity: 0.01,             // Weak central gravity like in D3
                    springLength: 200,                // Similar to d3.forceLink().distance(200)
                    springConstant: 0.04,             // Moderate spring constant
                    damping: 0.09,
                    avoidOverlap: 1.0                 // Maximum avoidance (d3.forceCollide)
                },
                solver: 'barnesHut',
                stabilization: {
                    enabled: true,
                    iterations: 250,                  // More iterations for better stability
                    updateInterval: 25,
                    onlyDynamicEdges: false,
                    fit: true
                },
                timestep: 0.3,                        // Smaller timestep for more stable simulation
                adaptiveTimestep: true,
                maxVelocity: 50,                      // Allow higher velocity initially (d3.alphaTarget(0.3))
                minVelocity: 0.15                     // Lower minimum velocity (d3's low friction)
            },
            interaction: {
                hover: true,
                tooltipDelay: 200,
                navigationButtons: true,
                keyboard: true,
                zoomView: true
            },
            layout: {
                randomSeed: 1,
                improvedLayout: true,
                clusterThreshold: 150             // Better clustering behavior
            }
        };
        
        // Load the network data from the API
        fetch(`/api/network_data/{{ filename }}`)
            .then(response => response.json())
            .then(data => {
                console.log("Received network data:", data);
                
                allNodes = new vis.DataSet(data.nodes);
                allEdges = new vis.DataSet(data.edges);
                
                // Create the network
                const networkData = {
                    nodes: allNodes,
                    edges: allEdges
                };
                
                console.log("Creating network with container:", container);
                console.log("Container exists:", !!container);
                if (container) {
                    console.log("Container dimensions:", container.offsetWidth, "x", container.offsetHeight);
                }
                
                network = new vis.Network(container, networkData, options);
                
                // Add search functionality
                document.getElementById('search-button').addEventListener('click', performSearch);
                document.getElementById('search-input').addEventListener('keyup', function(event) {
                    if (event.key === "Enter") {
                        performSearch();
                    }
                });
                
                function performSearch() {
                    const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
                    if (!searchTerm) return;
                    
                    console.log("Searching for:", searchTerm);
                    
                    // Get all nodes
                    const nodeIds = network.getNodeIds();
                    const foundNodes = [];
                    
                    // Search through nodes
                    nodeIds.forEach(id => {
                        const node = networkData.nodes.get(id);
                        if (node.label.toLowerCase().includes(searchTerm)) {
                            foundNodes.push(id);
                        }
                    });
                    
                    if (foundNodes.length > 0) {
                        // Focus on the first match
                        network.focus(foundNodes[0], {
                            scale: 1.2,
                            animation: true
                        });
                        network.selectNodes(foundNodes);
                        
                        // Highlight the found nodes
                        const updatedNodes = foundNodes.map(id => {
                            const node = networkData.nodes.get(id);
                            const originalColor = node.color ? { ...node.color } : null;
                            
                            return {
                                id: id,
                                color: {
                                    background: '#FFFF00',
                                    border: '#FFA500',
                                    highlight: {
                                        background: '#FFFF00',
                                        border: '#FFA500'
                                    },
                                    _originalColor: originalColor
                                }
                            };
                        });
                        
                        networkData.nodes.update(updatedNodes);
                        
                        // Reset highlight after a delay
                        setTimeout(() => {
                            const resetNodes = foundNodes.map(id => {
                                const node = networkData.nodes.get(id);
                                return {
                                    id: id,
                                    color: node.color._originalColor
                                };
                            });
                            networkData.nodes.update(resetNodes);
                        }, 3000);
                        
                        console.log(`Found ${foundNodes.length} nodes matching "${searchTerm}"`);
                    } else {
                        console.log(`No nodes found matching "${searchTerm}"`);
                        alert(`No nodes found matching "${searchTerm}"`);
                    }
                }
                
                // Apply D3-style collision handling and boundary forces after initial stabilization
                network.once('stabilizationIterationsDone', function() {
                    console.log("Initial force-directed layout stabilized");
                    
                    setTimeout(() => {
                        // Apply collision handling and boundary forces
                        const nodeIds = network.getNodeIds();
                        const positions = network.getPositions(nodeIds);
                        const containerRect = document.getElementById('network-container').getBoundingClientRect();
                        
                        // Get dimensions for boundary constraints (similar to D3 example's transform function)
                        const width = containerRect.width;
                        const height = containerRect.height;
                        const nodeRadius = 25; // Similar to D3 example
                        const forcePadding = nodeRadius + 10;
                        
                        // Apply container boundary constraints to keep nodes within visible area
                        nodeIds.forEach(nodeId => {
                            const pos = positions[nodeId];
                            if (!pos) return;
                            
                            // Apply boundary constraints similar to D3 transform function
                            let x = pos.x;
                            let y = pos.y;
                            
                            // Apply padding to keep nodes within boundaries
                            x = x <= -width/2 + forcePadding ? -width/2 + forcePadding : 
                                x >= width/2 - forcePadding ? width/2 - forcePadding : x;
                            y = y <= -height/2 + forcePadding ? -height/2 + forcePadding : 
                                y >= height/2 - forcePadding ? height/2 - forcePadding : y;
                            
                            // Move node if needed
                            if (x !== pos.x || y !== pos.y) {
                                network.moveNode(nodeId, x, y);
                            }
                        });
                        
                        // Set gentler physics for ongoing simulation
                        network.setOptions({
                            physics: {
                                enabled: true,
                                maxVelocity: 5,        // Reduce max velocity after layout
                                minVelocity: 0.1,      // Gentle movement threshold
                                stabilization: {
                                    enabled: false     // Disable further full stabilization
                                }
                            }
                        });
                    }, 1000);
                });
                
                // Network events
                network.on("doubleClick", function(params) {
                    if (params.nodes.length > 0) {
                        // Focus on the selected node
                        network.focus(params.nodes[0], {
                            scale: 1.2,
                            animation: true
                        });
                    }
                });
                
                // Stabilize the network for better initial layout
                network.once("stabilizationIterationsDone", function() {
                    console.log("Network stabilized");
                    
                    // Apply a final layout adjustment to spread nodes further
                    const nodeIds = network.getNodeIds();
                    const positions = network.getPositions(nodeIds);
                    const nodeData = allNodes.get();
                    
                    // Group nodes by type
                    const ipNodes = nodeData.filter(node => node.group === 'ip').map(node => node.id);
                    const macNodes = nodeData.filter(node => node.group === 'mac').map(node => node.id);
                    
                    // Scale positions outward by different factors based on node type
                    // IP nodes get more expansion than MAC nodes
                    for (const nodeId of nodeIds) {
                        const pos = positions[nodeId];
                        if (ipNodes.includes(nodeId)) {
                            // IP nodes get expanded more (40% scaling)
                            network.moveNode(nodeId, pos.x * 1.4, pos.y * 1.4);
                        } else {
                            // MAC nodes get normal expansion (20% scaling)
                            network.moveNode(nodeId, pos.x * 1.2, pos.y * 1.2);
                        }
                    }
                    
                    // Disable physics after stabilization
                    network.setOptions({ physics: { enabled: false } });
                    
                    // Call resize after stabilization
                    setTimeout(resizeNetwork, 100);
                });
                
                // Set up search functionality
                setupSearch(network, allNodes);
                
                // Set up filter buttons
                setupFilters(network, allNodes, allEdges);
                
                // Set up layout buttons
                setupLayouts(network);
                
                // Set up action buttons
                setupActionButtons(network, container);
            })
            .catch(error => {
                console.error('Error loading network data:', error);
                container.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-full">
                        <i class="fas fa-exclamation-triangle text-error text-4xl mb-4"></i>
                        <h3 class="text-xl font-bold text-gray-800 mb-2">Error Loading Data</h3>
                        <p class="text-gray-600">Failed to load network data: ${error.message}</p>
                    </div>
                `;
            });
        
        // Setup search functionality
        function setupSearch(network, nodes) {
            const searchInput = document.getElementById('search-input');
            searchInput.addEventListener('input', function(e) {
                const searchTerm = e.target.value.toLowerCase();
                
                if (searchTerm === '') {
                    // Reset all nodes to visible
                    nodes.forEach(node => {
                        nodes.update({ id: node.id, hidden: false });
                    });
                    return;
                }
                
                // Hide nodes that don't match the search term
                nodes.forEach(node => {
                    const label = (node.label || '').toLowerCase();
                    const title = (node.title || '').toLowerCase();
                    const matches = label.includes(searchTerm) || title.includes(searchTerm);
                    nodes.update({ id: node.id, hidden: !matches });
                });
            });
        }
        
        // Setup filter buttons
        function setupFilters(network, nodes, edges) {
            const btnAll = document.getElementById('filter-all');
            const btnMac = document.getElementById('filter-mac');
            const btnIp = document.getElementById('filter-ip');
            
            btnAll.addEventListener('click', function() {
                // Show all nodes
                nodes.forEach(node => {
                    nodes.update({ id: node.id, hidden: false });
                });
                
                // Update button styles
                updateFilterButtonStyles(btnAll);
            });
            
            btnMac.addEventListener('click', function() {
                // Show MAC nodes, hide IP nodes
                nodes.forEach(node => {
                    const isMac = node.group === 'mac';
                    nodes.update({ id: node.id, hidden: !isMac });
                });
                
                // Update button styles
                updateFilterButtonStyles(btnMac);
            });
            
            btnIp.addEventListener('click', function() {
                // Show IP nodes, hide MAC nodes
                nodes.forEach(node => {
                    const isIp = node.group === 'ip';
                    nodes.update({ id: node.id, hidden: !isIp });
                });
                
                // Update button styles
                updateFilterButtonStyles(btnIp);
            });
            
            function updateFilterButtonStyles(activeButton) {
                // Reset all button styles
                [btnAll, btnMac, btnIp].forEach(btn => {
                    btn.classList.remove('bg-primary', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-800');
                });
                
                // Set active button style
                activeButton.classList.remove('bg-gray-200', 'text-gray-800');
                activeButton.classList.add('bg-primary', 'text-white');
            }
        }
        
        // Setup layout buttons
        function setupLayouts(network) {
            const btnHierarchical = document.getElementById('layout-hierarchical');
            const btnPhysics = document.getElementById('layout-physics');
            
            // Hierarchical button handler
            btnHierarchical.addEventListener('click', function() {
                // Update button styles first
                updateLayoutButtonStyles(btnHierarchical);
                
                console.log("Switching to Hierarchical view");
                
                // Explicitly enable hierarchical layout and disable physics
                network.setOptions({
                    physics: { 
                        enabled: false 
                    },
                    layout: {
                        hierarchical: {
                            enabled: true,  // Explicitly enable hierarchical layout
                            direction: 'LR',
                            sortMethod: 'directed',
                            nodeSpacing: 250,         // Increased node spacing
                            levelSeparation: 300,     // Increased level separation
                            treeSpacing: 200          // Added tree spacing
                        }
                    }
                });
            });
            
            // Force Directed button handler
            btnPhysics.addEventListener('click', function() {
                // Update button styles first
                updateLayoutButtonStyles(btnPhysics);
                
                console.log("Switching to Force Directed view");
                
                // First disable hierarchical layout explicitly, then enable physics
                network.setOptions({
                    layout: { 
                        hierarchical: { 
                            enabled: false  // Explicitly disable hierarchical layout
                        } 
                    }
                });
                
                // Separate call to enable physics
                network.setOptions({
                    physics: {
                        enabled: true,
                        // D3-style physics configuration
                        barnesHut: {
                            gravitationalConstant: -2000,     // Similar to d3.forceManyBody().strength(-200)
                            centralGravity: 0.01,             // Weak central gravity like in D3
                            springLength: 200,                // Similar to d3.forceLink().distance(200)
                            springConstant: 0.04,             // Moderate spring constant
                            damping: 0.09,                    
                            avoidOverlap: 1.0                 // Maximum avoidance (d3.forceCollide)
                        },
                        solver: 'barnesHut',
                        stabilization: {
                            enabled: true,
                            iterations: 250,                  // More iterations for better stability
                            updateInterval: 25,
                            onlyDynamicEdges: false,
                            fit: false                        // Don't fit to view to preserve positions
                        },
                        timestep: 0.3,                        // Smaller timestep for more stable simulation
                        adaptiveTimestep: true,
                        maxVelocity: 50,                      // Allow higher velocity initially
                        minVelocity: 0.15                     // Lower minimum velocity
                    }
                });
                
                // Apply collision handling after physics has started
                setTimeout(function() {
                    applyCollisionHandling();
                }, 1000);
            });
            
            function updateLayoutButtonStyles(activeButton) {
                // Reset all button styles
                [btnHierarchical, btnPhysics].forEach(btn => {
                    btn.classList.remove('bg-primary', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-800');
                });
                
                // Set active button style
                activeButton.classList.remove('bg-gray-200', 'text-gray-800');
                activeButton.classList.add('bg-primary', 'text-white');
            }
            
            // Helper function to apply D3-style collision handling and boundary forces
            function applyCollisionHandling() {
                const nodeIds = network.getNodeIds();
                const positions = network.getPositions(nodeIds);
                const containerRect = document.getElementById('network-container').getBoundingClientRect();
                
                // Get dimensions to apply boundary constraints
                const width = containerRect.width;
                const height = containerRect.height;
                const nodeRadius = 25;
                const forcePadding = nodeRadius + 10;
                
                console.log("Applying collision handling to", nodeIds.length, "nodes");
                
                // Apply container boundary constraints
                nodeIds.forEach(nodeId => {
                    const pos = positions[nodeId];
                    if (!pos) return;
                    
                    // Apply boundary constraints
                    let x = pos.x;
                    let y = pos.y;
                    
                    // Apply padding to keep nodes within boundaries
                    x = x <= -width/2 + forcePadding ? -width/2 + forcePadding : 
                        x >= width/2 - forcePadding ? width/2 - forcePadding : x;
                    y = y <= -height/2 + forcePadding ? -height/2 + forcePadding : 
                        y >= height/2 - forcePadding ? height/2 - forcePadding : y;
                    
                    // Move node if position changed
                    if (x !== pos.x || y !== pos.y) {
                        network.moveNode(nodeId, x, y);
                    }
                });
                
                // Reduce velocity after collision handling
                network.setOptions({
                    physics: {
                        maxVelocity: 5,
                        minVelocity: 0.1
                    }
                });
            }
        }
        
        // Setup action buttons
        function setupActionButtons(network, container) {
            const btnFullscreen = document.getElementById('btn-fullscreen');
            const btnExport = document.getElementById('btn-export');
            
            btnFullscreen.addEventListener('click', function() {
                // Use the visualization-container for fullscreen
                const visualizationContainer = document.getElementById('network-container');
                if (!document.fullscreenElement) {
                    visualizationContainer.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable fullscreen: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            });
            
            btnExport.addEventListener('click', function() {
                // Export the current network view as an image
                const networkContainer = document.getElementById('network-container');
                if (networkContainer) {
                    html2canvas(networkContainer).then(canvas => {
                        const imageData = canvas.toDataURL('image/png');
                        const link = document.createElement('a');
                        link.href = imageData;
                        link.download = `network_visualization_${Date.now()}.png`;
                        link.click();
                    });
                }
            });
        }
        
        // Fix: Update the resize function to use the correct container
        function resizeNetwork() {
            if (network) {
                // Calculate available height
                const headerHeight = document.querySelector('header').offsetHeight;
                const controlsHeight = document.querySelector('.compact-controls').offsetHeight;
                const legendHeight = document.querySelector('.compact-legend').offsetHeight;
                const footerHeight = document.querySelector('footer').offsetHeight;
                const spacing = 30; // Extra spacing/margins
                
                // Calculate available height
                const availableHeight = window.innerHeight - headerHeight - controlsHeight - legendHeight - footerHeight - spacing;
                
                // Set visualization container height
                const visualizationContainer = document.getElementById('network-container');
                visualizationContainer.style.height = `${availableHeight}px`;
                
                // Update network size
                network.setSize('100%', '100%');
                network.redraw();
            }
        }
        
        // Call resize on load and window resize
        window.addEventListener('resize', resizeNetwork);
    });
</script>
{% endblock %} 